import { serve } from "./runtime.bundle.js";

!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.getLatestVersion=t.getBackingURL=t.parsePathname=t.handleRegistryRequest=t.S3_BUCKET=void 0;const i=n(3);function o(e){if(e.startsWith("/std"))return o("/x"+e);if(!e.startsWith("/x/"))return;const t=e.replace(/^\/x\//,""),[n,...r]=t.split("/"),[s,a]=i.parseNameVersion(n);return{module:s,version:a,path:r.join("/")}}function s(e,n,r){return`${t.S3_BUCKET}${e}/versions/${n}/raw/${r}`}function a(e){return r(this,void 0,void 0,(function*(){const n=yield fetch(`${t.S3_BUCKET}${e}/meta/versions.json`);if(!n.ok)return;const r=yield n.json();return null==r?void 0:r.latest}))}t.S3_BUCKET="http://deno-registry2-prod-storagebucket-b3a31d16.s3-website-us-east-1.amazonaws.com/",t.handleRegistryRequest=function(e){var t,n;return r(this,void 0,void 0,(function*(){console.log("registry request",e.pathname);const r=o(e.pathname);if(!r)return new Response("This module entry is invalid: "+e.pathname,{status:400,headers:{"content-type":"text/plain"}});const{module:i,version:u,path:d}=r;if(!u){const t=yield a(i);return t?(console.log("registry redirect",i,t),new Response(void 0,{headers:{Location:`${"std"===i?"":"/x"}/${i}@${t}/${d}`,"x-deno-warning":`Implicitly using latest version (${t}) for ${e.origin}${"std"===i?"":"/x"}/${i}/${d}`},status:302})):new Response("This module has no latest version: "+e.pathname,{status:404,headers:{"content-type":"text/plain"}})}if(u.startsWith("v0.")&&"std"===i){console.log("std version prefix",i,u);const t=u.substring(1);return parseFloat(t)>=.43?new Response("404 Not Found",{headers:{"x-deno-warning":`std versions prefixed with 'v' were deprecated recently. Please change your import to ${e.origin}${"std"===i?"":"/x"}/${i}@${t}/${d} (at ${e.origin}${"std"===i?"":"/x"}/${i}@${u}/${d})`},status:404}):new Response(void 0,{headers:{Location:`/std@${t}/${d}`,"x-deno-warning":`std versions prefixed with 'v' will be deprecated soon. Please change your import to ${e.origin}${"std"===i?"":"/x"}/${i}@${t}/${d} (at ${e.origin}${"std"===i?"":"/x"}/${i}@${u}/${d})`},status:302})}const c=s(i,u,d),l=yield fetch(c,{cf:{cacheEverything:!0}}),f=403===l.status||404===l.status?new Response("404 Not Found",{status:404}):new Response(l.body,l);return c.endsWith(".jsx")&&!(null===(t=f.headers.get("content-type"))||void 0===t?void 0:t.includes("javascript"))?f.headers.set("content-type","application/javascript"):c.endsWith(".tsx")&&!(null===(n=f.headers.get("content-type"))||void 0===n?void 0:n.includes("typescript"))&&f.headers.set("content-type","application/typescript"),f.headers.set("Access-Control-Allow-Origin","*"),f}))},t.parsePathname=o,t.getBackingURL=s,t.getLatestVersion=a},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(2);addEventListener("fetch",e=>{e.respondWith(r.handleRequest(e.request))})},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.extractAltLineNumberReference=t.handleRequest=void 0;const i=n(0),o=n(4);t.handleRequest=function(e){return r(this,void 0,void 0,(function*(){const t=e.headers.get("accept"),n=t&&t.indexOf("html")>=0,r=new URL(e.url);if("/v1"===r.pathname)return Response.redirect("https://deno.land/posts/v1",301);if(r.pathname.startsWith("/typedoc"))return Response.redirect("https://doc.deno.land/builtin/stable",301);if(r.pathname.startsWith("/_vsc"))return o.handleVSCRequest(r);if(r.pathname.startsWith("/std")||r.pathname.startsWith("/x/")){if(!n)return i.handleRegistryRequest(r);{const e=a(r.toString());if(e)return Response.redirect(e.rest+"#L"+e.line,302)}}return function(e,t,n){const r={method:n.method,headers:n.headers},i=t+e.pathname;console.log(`Proxy ${e} to ${i}`);const o=new Request(i,r);return console.log("modifiedRequest",o.url),fetch(o)}(r,"https://deno-website2.now.sh",e)}))};const s=/(.*):(\d+):\d+$/;function a(e){const t=s.exec(e);return null===t?null:{rest:t[1],line:parseInt(t[2])}}t.extractAltLineNumberReference=a},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.getStats=t.listExternalDependencies=t.flattenGraph=t.graphToTree=t.isReadme=t.findRootReadme=t.denoDocAvailableForURL=t.fileNameFromURL=t.fileTypeFromURL=t.parseNameVersion=t.getBuild=t.getModule=t.listModules=t.getVersionList=t.getVersionDeps=t.getVersionMeta=t.getRepositoryURL=t.getSourceURL=void 0;const i="https://cdn.deno.land/",o="https://api.deno.land/";function s(e){const t=e.toLowerCase();return t.endsWith(".ts")?"typescript":t.endsWith(".js")?"javascript":t.endsWith(".tsx")?"tsx":t.endsWith(".jsx")?"jsx":t.endsWith(".json")?"json":t.endsWith(".toml")||t.endsWith(".lock")?"toml":t.endsWith(".rs")?"rust":t.endsWith(".py")?"python":t.endsWith(".wasm")?"wasm":t.toLocaleLowerCase().endsWith("makefile")?"makefile":t.endsWith(".dockerfile")||t.endsWith("dockerfile")?"dockerfile":t.endsWith(".yml")||t.endsWith(".yaml")?"yaml":t.endsWith(".htm")||t.endsWith(".html")?"html":t.endsWith(".md")||t.endsWith(".markdown")||t.endsWith(".mdown")||t.endsWith(".mkdn")||t.endsWith(".mdwn")||t.endsWith(".mkd")?"markdown":t.endsWith(".png")||t.endsWith(".jpg")||t.endsWith(".jpeg")?"image":void 0}function a(e,t,n=[]){const r=e.nodes[t];if(void 0!==r)return n.push(t),r.deps.filter(e=>!n.includes(e)).forEach(t=>a(e,t,n)),n}function u(e){const t=e.match(/^https:\/\/deno\.land\/x\/([^/]+)(.+)$/);if(t)return{identifier:t[1],path:t[2]}}function d(e){const t=e.match(/^https:\/\/deno\.land\/(x\/)?std(@([^/]+))?(.+)?$/);if(t)return{version:t[2],submodule:t[4],path:t[5]}}t.getSourceURL=function(e,t,n){return encodeURI(`${i}${e}/versions/${t}/raw${n}`)},t.getRepositoryURL=function(e,t){var n;switch(e.uploadOptions.type){case"github":return"https://github.com/"+function(...e){const t=new RegExp("/{1,}","g");return e.join("/").replace(t,"/")}(e.uploadOptions.repository,"tree",e.uploadOptions.ref,null!==(n=e.uploadOptions.subdir)&&void 0!==n?n:"",t);default:return}},t.getVersionMeta=function(e,t){return r(this,void 0,void 0,(function*(){const n=`${i}${e}/versions/${t}/meta/meta.json`,r=yield fetch(n,{headers:{accept:"application/json"}});if(403===r.status||404===r.status)return null;if(200!==r.status)throw Error(`Got an error (${r.status}) while getting the directory listing:\n${yield r.text()}`);const o=yield r.json();return o?{uploadedAt:new Date(o.uploaded_at),directoryListing:o.directory_listing,uploadOptions:o.upload_options}:null}))},t.getVersionDeps=function(e,t){return r(this,void 0,void 0,(function*(){const n=`${i}${e}/versions/${t}/meta/deps_v2.json`,r=yield fetch(n,{headers:{accept:"application/json"}});if(403===r.status||404===r.status)return null;if(200!==r.status)throw Error(`Got an error (${r.status}) while getting the dependency information:\n${yield r.text()}`);const o=yield r.json();return o?{graph:o.graph}:null}))},t.getVersionList=function(e){return r(this,void 0,void 0,(function*(){const t=`${i}${e}/meta/versions.json`,n=yield fetch(t,{headers:{accept:"application/json"}});if(403===n.status||404===n.status)return null;if(200!==n.status)throw Error(`Got an error (${n.status}) while getting the version list:\n${yield n.text()}`);return n.json()}))},t.listModules=function(e,t,n){return r(this,void 0,void 0,(function*(){const r=`${o}modules?page=${e}&limit=${t}&query=${encodeURIComponent(n)}`,i=yield fetch(r,{headers:{accept:"application/json"}});if(200!==i.status)throw Error(`Got an error (${i.status}) while getting the module list:\n${yield i.text()}`);const s=yield i.json();if(!s.success)throw Error(`Got an error (${s.info}) while getting the module list:\n${yield i.text()}`);return{totalCount:s.data.total_count,results:s.data.results}}))},t.getModule=function(e){return r(this,void 0,void 0,(function*(){const t=`${o}modules/${encodeURIComponent(e)}`,n=yield fetch(t,{headers:{accept:"application/json"}});if(404===n.status)return null;if(200!==n.status)throw Error(`Got an error (${n.status}) while getting the module ${e}:\n${yield n.text()}`);const r=yield n.json();if(!r.success)throw Error(`Got an error (${r.info}) while getting the module ${e}:\n${yield n.text()}`);return r.data}))},t.getBuild=function(e){return r(this,void 0,void 0,(function*(){const t=`${o}builds/${e}`,n=yield fetch(t,{headers:{accept:"application/json"}});if(200!==n.status)throw Error(`Got an error (${n.status}) while getting the build info:\n${yield n.text()}`);const r=yield n.json();if(!r.success)throw Error(`Got an error (${r.info}) while getting the build info:\n${yield n.text()}`);return r.data.build}))},t.parseNameVersion=function(e){const[t,n]=e.split("@",2);return[t,n]},t.fileTypeFromURL=s,t.fileNameFromURL=function(e){const t=decodeURI(e).split("/");return t[t.length-1]},t.denoDocAvailableForURL=function(e){switch(s(e)){case"javascript":case"typescript":case"jsx":case"tsx":return!0;default:return!1}},t.findRootReadme=function(e){const t=null==e?void 0:e.find(e=>/^\/(docs\/|\.github\/)?readme(\.markdown|\.mdown|\.mkdn|\.mdwn|\.mkd|\.md)?$/i.test(e.path));return t?{name:t.path.substring(1),type:t.type,size:t.size}:void 0},t.isReadme=function(e){return/^readme(\.markdown|\.mdown|\.mkdn|\.mdwn|\.mkd|\.md)?$/i.test(e)},t.graphToTree=function e(t,n,r=[]){const i=t.nodes[n];if(void 0!==i)return r.push(n),{name:n,children:i.deps.filter(e=>!r.includes(e)).map(n=>e(t,n,r))}},t.flattenGraph=a,t.listExternalDependencies=function(e,t){var n;const r=a(e,t),i=new Set,o=new Set,s=new Set,c=new Set,l=new Set,f=new Set;if(r){r.forEach(e=>{var t;const n=d(e);if(n)return void i.add("https://deno.land/std"+(null!==(t=n.version)&&void 0!==t?t:""));const r=u(e);if(r)return void i.add("https://deno.land/x/"+r.identifier);const a=e.match(/^https:\/\/x\.nest\.land\/([^/]+)(.+)$/);if(a)return void o.add("https://nest.land/packages/"+a[1]);const p=e.match(/^https:\/\/raw\.githubusercontent\.com\/([^/]+)\/([^/]+)\/([^/]+)(.+)$/);if(p)return void s.add(`https://github.com/${p[1]}/${p[2]}/tree/${p[3]}`);const h=e.match(/^https:\/\/dev\.jspm\.io\/(npm:)?(@([^/@]+)\/([^/@]+)|([^/@]+))@(\d\.\d\.\d)(.+)$/);if(h)return void c.add(`https://dev.jspm.io/${h[2]}@${h[6]}`);if(e.startsWith("https://dev.jspm.io"))return;const v=e.match(/^https:\/\/cdn\.depjs\.com\/([^/]+)(.+)$/);v?l.add("https://cdn.depjs.com/"+v[1]):e.startsWith("https://cdn.pika.dev/-/")||f.add(e)});const e=d(t);e&&i.delete("https://deno.land/std"+(null!==(n=e.version)&&void 0!==n?n:""));const a=u(t);return a&&i.delete("https://deno.land/x/"+a.identifier),[...i,...o,...s,...c,...l,...f].map(e=>e.replace("https://deno.land/x/std","https://deno.land/std"))}},t.getStats=function(){return r(this,void 0,void 0,(function*(){const e=yield fetch("https://api.deno.land/stats",{headers:{accept:"application/json"}});if(200!==e.status)throw Error(`Got an error (${e.status}) while getting the stats:\n${yield e.text()}`);const t=yield e.json();if(!t.success)throw Error(`Got an error (${t.info}) while getting the stats:\n${yield e.text()}`);return t.data}))}},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.handleVSCRequest=void 0;const i=n(5),o=n(0),s=i.match("/_vsc1/modules/:module([a-z0-9_]*)"),a=i.match("/_vsc1/modules/:module([a-z0-9_]*)/v/:version"),u=i.match("/_vsc1/modules/:module([a-z0-9_]*)/v_latest");function d(e,t){return r(this,void 0,void 0,(function*(){const n=yield fetch(`${o.S3_BUCKET}${e}/versions/${t}/meta/meta.json`);if(403===n.status||404===n.status)return new Response("module or version not found",{status:404});if(!n.ok)return new Response("internal server error 2",{status:500});const r=(yield n.json()).directory_listing.filter(e=>"file"===e.type&&!e.path.includes("/_")).map(e=>e.path.substring(1)).filter(e=>e.endsWith(".jsx")||e.endsWith(".jsx")||e.endsWith(".ts")||e.endsWith(".tsx")||e.endsWith(".mjs"));return new Response(JSON.stringify(r),{status:200,headers:{"content-type":"application/json","cache-control":"max-age=86400"}})}))}t.handleVSCRequest=function(e){return r(this,void 0,void 0,(function*(){const t=e.pathname,n=s(t);if(n){const e=n.params.module,t=yield fetch(`${o.S3_BUCKET}${e}/meta/versions.json`);if(403===t.status||404===t.status)return new Response("module not found",{status:404});if(!t.ok)return new Response("internal server error 1",{status:500});const r=yield t.json();return new Response(JSON.stringify(r.versions),{status:200,headers:{"content-type":"application/json","cache-control":"max-age=86400"}})}const r=a(t);if(r){return d(r.params.module,r.params.version)}const i=u(t);if(i){const e=i.params.module,t=yield fetch(`${o.S3_BUCKET}${e}/meta/versions.json`);if(403===t.status||404===t.status)return new Response("module not found",{status:404});if(!t.ok)return new Response("internal server error 3",{status:500});const n=yield t.json();return n.latest?d(e,n.latest):new Response("no latest version",{status:404})}return new Response("not found",{status:404})}))}},function(e,t,n){"use strict";function r(e,t){void 0===t&&(t={});for(var n=function(e){for(var t=[],n=0;n<e.length;){var r=e[n];if("*"!==r&&"+"!==r&&"?"!==r)if("\\"!==r)if("{"!==r)if("}"!==r)if(":"!==r)if("("!==r)t.push({type:"CHAR",index:n,value:e[n++]});else{var i=1,o="";if("?"===e[a=n+1])throw new TypeError('Pattern cannot start with "?" at '+a);for(;a<e.length;)if("\\"!==e[a]){if(")"===e[a]){if(0===--i){a++;break}}else if("("===e[a]&&(i++,"?"!==e[a+1]))throw new TypeError("Capturing groups are not allowed at "+a);o+=e[a++]}else o+=e[a++]+e[a++];if(i)throw new TypeError("Unbalanced pattern at "+n);if(!o)throw new TypeError("Missing pattern at "+n);t.push({type:"PATTERN",index:n,value:o}),n=a}else{for(var s="",a=n+1;a<e.length;){var u=e.charCodeAt(a);if(!(u>=48&&u<=57||u>=65&&u<=90||u>=97&&u<=122||95===u))break;s+=e[a++]}if(!s)throw new TypeError("Missing parameter name at "+n);t.push({type:"NAME",index:n,value:s}),n=a}else t.push({type:"CLOSE",index:n,value:e[n++]});else t.push({type:"OPEN",index:n,value:e[n++]});else t.push({type:"ESCAPED_CHAR",index:n++,value:e[n++]});else t.push({type:"MODIFIER",index:n,value:e[n++]})}return t.push({type:"END",index:n,value:""}),t}(e),r=t.prefixes,i=void 0===r?"./":r,o="[^"+u(t.delimiter||"/#?")+"]+?",s=[],a=0,d=0,c="",l=function(e){if(d<n.length&&n[d].type===e)return n[d++].value},f=function(e){var t=l(e);if(void 0!==t)return t;var r=n[d],i=r.type,o=r.index;throw new TypeError("Unexpected "+i+" at "+o+", expected "+e)},p=function(){for(var e,t="";e=l("CHAR")||l("ESCAPED_CHAR");)t+=e;return t};d<n.length;){var h=l("CHAR"),v=l("NAME"),m=l("PATTERN");if(v||m){var y=h||"";-1===i.indexOf(y)&&(c+=y,y=""),c&&(s.push(c),c=""),s.push({name:v||a++,prefix:y,suffix:"",pattern:m||o,modifier:l("MODIFIER")||""})}else{var g=h||l("ESCAPED_CHAR");if(g)c+=g;else if(c&&(s.push(c),c=""),l("OPEN")){y=p();var w=l("NAME")||"",x=l("PATTERN")||"",$=p();f("CLOSE"),s.push({name:w||(x?a++:""),pattern:w&&!x?o:x,prefix:y,suffix:$,modifier:l("MODIFIER")||""})}else f("END")}}return s}function i(e,t){return o(r(e,t),t)}function o(e,t){void 0===t&&(t={});var n=d(t),r=t.encode,i=void 0===r?function(e){return e}:r,o=t.validate,s=void 0===o||o,a=e.map((function(e){if("object"==typeof e)return new RegExp("^(?:"+e.pattern+")$",n)}));return function(t){for(var n="",r=0;r<e.length;r++){var o=e[r];if("string"!=typeof o){var u=t?t[o.name]:void 0,d="?"===o.modifier||"*"===o.modifier,c="*"===o.modifier||"+"===o.modifier;if(Array.isArray(u)){if(!c)throw new TypeError('Expected "'+o.name+'" to not repeat, but got an array');if(0===u.length){if(d)continue;throw new TypeError('Expected "'+o.name+'" to not be empty')}for(var l=0;l<u.length;l++){var f=i(u[l],o);if(s&&!a[r].test(f))throw new TypeError('Expected all "'+o.name+'" to match "'+o.pattern+'", but got "'+f+'"');n+=o.prefix+f+o.suffix}}else if("string"!=typeof u&&"number"!=typeof u){if(!d){var p=c?"an array":"a string";throw new TypeError('Expected "'+o.name+'" to be '+p)}}else{f=i(String(u),o);if(s&&!a[r].test(f))throw new TypeError('Expected "'+o.name+'" to match "'+o.pattern+'", but got "'+f+'"');n+=o.prefix+f+o.suffix}}else n+=o}return n}}function s(e,t){var n=[];return a(l(e,n,t),n,t)}function a(e,t,n){void 0===n&&(n={});var r=n.decode,i=void 0===r?function(e){return e}:r;return function(n){var r=e.exec(n);if(!r)return!1;for(var o=r[0],s=r.index,a=Object.create(null),u=function(e){if(void 0===r[e])return"continue";var n=t[e-1];"*"===n.modifier||"+"===n.modifier?a[n.name]=r[e].split(n.prefix+n.suffix).map((function(e){return i(e,n)})):a[n.name]=i(r[e],n)},d=1;d<r.length;d++)u(d);return{path:o,index:s,params:a}}}function u(e){return e.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function d(e){return e&&e.sensitive?"":"i"}function c(e,t,n){void 0===n&&(n={});for(var r=n.strict,i=void 0!==r&&r,o=n.start,s=void 0===o||o,a=n.end,c=void 0===a||a,l=n.encode,f=void 0===l?function(e){return e}:l,p="["+u(n.endsWith||"")+"]|$",h="["+u(n.delimiter||"/#?")+"]",v=s?"^":"",m=0,y=e;m<y.length;m++){var g=y[m];if("string"==typeof g)v+=u(f(g));else{var w=u(f(g.prefix)),x=u(f(g.suffix));if(g.pattern)if(t&&t.push(g),w||x)if("+"===g.modifier||"*"===g.modifier){var $="*"===g.modifier?"?":"";v+="(?:"+w+"((?:"+g.pattern+")(?:"+x+w+"(?:"+g.pattern+"))*)"+x+")"+$}else v+="(?:"+w+"("+g.pattern+")"+x+")"+g.modifier;else v+="("+g.pattern+")"+g.modifier;else v+="(?:"+w+x+")"+g.modifier}}if(c)i||(v+=h+"?"),v+=n.endsWith?"(?="+p+")":"$";else{var R=e[e.length-1],E="string"==typeof R?h.indexOf(R[R.length-1])>-1:void 0===R;i||(v+="(?:"+h+"(?="+p+"))?"),E||(v+="(?="+h+"|"+p+")")}return new RegExp(v,d(n))}function l(e,t,n){return e instanceof RegExp?function(e,t){if(!t)return e;for(var n=/\((?:\?<(.*?)>)?(?!\?)/g,r=0,i=n.exec(e.source);i;)t.push({name:i[1]||r++,prefix:"",suffix:"",modifier:"",pattern:""}),i=n.exec(e.source);return e}(e,t):Array.isArray(e)?function(e,t,n){var r=e.map((function(e){return l(e,t,n).source}));return new RegExp("(?:"+r.join("|")+")",d(n))}(e,t,n):function(e,t,n){return c(r(e,n),t,n)}(e,t,n)}n.r(t),n.d(t,"parse",(function(){return r})),n.d(t,"compile",(function(){return i})),n.d(t,"tokensToFunction",(function(){return o})),n.d(t,"match",(function(){return s})),n.d(t,"regexpToFunction",(function(){return a})),n.d(t,"tokensToRegexp",(function(){return c})),n.d(t,"pathToRegexp",(function(){return l}))}]);
//# sourceMappingURL=worker.js.map{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/registry.ts","webpack:///./src/index.ts","webpack:///./src/handler.ts","webpack:///../util/registry_utils.ts","webpack:///./src/vscode.ts","webpack:///../src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parsePathname","pathname","startsWith","nameBranchRest","replace","nameBranch","rest","split","version","parseNameVersion","path","join","getBackingURL","S3_BUCKET","getLatestVersion","res","fetch","ok","versions","json","latest","url","console","log","entry","Response","status","headers","undefined","Location","origin","correctVersion","substring","parseFloat","remoteUrl","resp","cf","cacheEverything","resp2","body","endsWith","includes","set","addEventListener","event","respondWith","handleRequest","request","accept","isHtml","indexOf","URL","redirect","handleVSCRequest","handleRegistryRequest","ln","extractAltLineNumberReference","toString","line","init","method","urlR","modifiedRequest","Request","proxyFile","ALT_LINENUMBER_MATCHER","matches","exec","parseInt","CDN_ENDPOINT","API_ENDPOINT","fileTypeFromURL","filename","f","toLowerCase","toLocaleLowerCase","flattenGraph","graph","visited","dep","nodes","push","deps","filter","forEach","matchX","match","identifier","matchStd","submodule","encodeURI","meta","uploadOptions","type","parts","RegExp","pathJoin","repository","ref","subdir","Error","text","uploadedAt","Date","uploaded_at","directoryListing","directory_listing","upload_options","page","limit","query","encodeURIComponent","data","success","info","totalCount","total_count","results","id","build","nameVersion","segments","decodeURI","length","listing","find","test","size","graphToTree","children","map","denolandDeps","Set","nestlandDeps","rawGithubDeps","jspmDeps","depJsDeps","other","std","add","x","nest","rawGithub","jspm","depJs","thisStd","delete","thisX","VERSIONS","PATHS","PATHS_LATEST","getPaths","list","JSON","stringify","params","paths","pathsLatest","parse","str","options","tokens","char","index","count","pattern","j","TypeError","code","charCodeAt","lexer","prefixes","defaultPattern","escapeString","delimiter","result","tryConsume","mustConsume","nextType","consumeText","prefix","suffix","modifier","compile","tokensToFunction","reFlags","flags","encode","validate","token","optional","repeat","Array","isArray","segment","typeOfMessage","String","keys","regexpToFunction","pathToRegexp","re","decode","sensitive","tokensToRegexp","strict","start","end","route","mod","endToken","isEndDelimited","groupsRegex","execResult","source","regexpToRegexp","arrayToRegexp","stringToRegexp"],"mappings":"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","file":"worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/* Copyright 2020 the Deno authors. All rights reserved. MIT license. */\n\nimport { parseNameVersion } from \"../../util/registry_utils\";\n\nexport const S3_BUCKET =\n  \"http://deno-registry2-prod-storagebucket-b3a31d16.s3-website-us-east-1.amazonaws.com/\";\n\nexport async function handleRegistryRequest(url: URL): Promise<Response> {\n  console.log(\"registry request\", url.pathname);\n  const entry = parsePathname(url.pathname);\n  if (!entry) {\n    return new Response(\"This module entry is invalid: \" + url.pathname, {\n      status: 400,\n      headers: { \"content-type\": \"text/plain\" },\n    });\n  }\n  const { module, version, path } = entry;\n  if (!version) {\n    const latest = await getLatestVersion(module);\n    if (!latest) {\n      return new Response(\n        \"This module has no latest version: \" + url.pathname,\n        {\n          status: 404,\n          headers: { \"content-type\": \"text/plain\" },\n        }\n      );\n    }\n    console.log(\"registry redirect\", module, latest);\n    return new Response(undefined, {\n      headers: {\n        Location: `${module === \"std\" ? \"\" : \"/x\"}/${module}@${latest}/${path}`,\n        \"x-deno-warning\": `Implicitly using latest version (${latest}) for ${\n          url.origin\n        }${module === \"std\" ? \"\" : \"/x\"}/${module}/${path}`,\n      },\n      status: 302,\n    });\n  }\n  if (version.startsWith(\"v0.\") && module === \"std\") {\n    console.log(\"std version prefix\", module, version);\n    const correctVersion = version.substring(1);\n    const versionNumber = parseFloat(correctVersion);\n    // For now only block std versions >= 0.43.0\n    // Timeline for deprecation:\n    // Oct 14 2020: >= 0.70.0\n    // Oct 21 2020: >= 0.68.0\n    // Oct 28 2020: >= 0.65.0\n    // Nov 04 2020: >= 0.61.0\n    // Nov 11 2020: >= 0.56.0\n    // Nov 18 2020: >= 0.50.0\n    // Nov 25 2020: >= 0.43.0\n    // Dec 02 2020: >= 0.34.0 (oldest available std release)\n    if (versionNumber >= 0.43) {\n      return new Response(\"404 Not Found\", {\n        headers: {\n          \"x-deno-warning\": `std versions prefixed with 'v' were deprecated recently. Please change your import to ${\n            url.origin\n          }${\n            module === \"std\" ? \"\" : \"/x\"\n          }/${module}@${correctVersion}/${path} (at ${url.origin}${\n            module === \"std\" ? \"\" : \"/x\"\n          }/${module}@${version}/${path})`,\n        },\n        status: 404,\n      });\n    }\n    return new Response(undefined, {\n      headers: {\n        Location: `/std@${correctVersion}/${path}`,\n        \"x-deno-warning\": `std versions prefixed with 'v' will be deprecated soon. Please change your import to ${\n          url.origin\n        }${\n          module === \"std\" ? \"\" : \"/x\"\n        }/${module}@${correctVersion}/${path} (at ${url.origin}${\n          module === \"std\" ? \"\" : \"/x\"\n        }/${module}@${version}/${path})`,\n      },\n      status: 302,\n    });\n  }\n  const remoteUrl = getBackingURL(module, version, path);\n  // @ts-ignore\n  const resp = await fetch(remoteUrl, { cf: { cacheEverything: true } });\n  const resp2 =\n    resp.status === 403 || resp.status === 404\n      ? new Response(\"404 Not Found\", { status: 404 })\n      : new Response(resp.body, resp);\n\n  // JSX and TSX content type fix\n  if (\n    remoteUrl.endsWith(\".jsx\") &&\n    !resp2.headers.get(\"content-type\")?.includes(\"javascript\")\n  ) {\n    resp2.headers.set(\"content-type\", \"application/javascript\");\n  } else if (\n    remoteUrl.endsWith(\".tsx\") &&\n    !resp2.headers.get(\"content-type\")?.includes(\"typescript\")\n  ) {\n    resp2.headers.set(\"content-type\", \"application/typescript\");\n  }\n\n  resp2.headers.set(\"Access-Control-Allow-Origin\", \"*\");\n  return resp2;\n}\n\nexport function parsePathname(\n  pathname: string\n): { module: string; version: string | undefined; path: string } | undefined {\n  if (pathname.startsWith(\"/std\")) {\n    return parsePathname(\"/x\" + pathname);\n  }\n  if (!pathname.startsWith(\"/x/\")) {\n    return undefined;\n  }\n  const nameBranchRest = pathname.replace(/^\\/x\\//, \"\");\n  const [nameBranch, ...rest] = nameBranchRest.split(\"/\");\n  const [name, version] = parseNameVersion(nameBranch);\n  const path = rest.join(\"/\");\n  return { module: name, version, path };\n}\n\nexport function getBackingURL(module: string, version: string, path: string) {\n  return `${S3_BUCKET}${module}/versions/${version}/raw/${path}`;\n}\n\nexport async function getLatestVersion(\n  module: string\n): Promise<string | undefined> {\n  const res = await fetch(`${S3_BUCKET}${module}/meta/versions.json`);\n  if (!res.ok) return undefined;\n  const versions = await res.json();\n  return versions?.latest;\n}\n","/* Copyright 2020 the Deno authors. All rights reserved. MIT license. */\n\nimport { handleRequest } from \"./handler\";\n\naddEventListener(\"fetch\", (event: FetchEvent) => {\n  event.respondWith(handleRequest(event.request));\n});\n","/* Copyright 2020 the Deno authors. All rights reserved. MIT license. */\n\nimport { handleRegistryRequest } from \"./registry\";\nimport { handleVSCRequest } from \"./vscode\";\n\nconst REMOTE_URL = \"https://deno-website2.now.sh\";\n\nexport async function handleRequest(request: Request) {\n  const accept = request.headers.get(\"accept\");\n  const isHtml = accept && accept.indexOf(\"html\") >= 0;\n\n  const url = new URL(request.url);\n\n  if (url.pathname === \"/v1\") {\n    return Response.redirect(\"https://deno.land/posts/v1\", 301);\n  }\n\n  if (url.pathname.startsWith(\"/typedoc\")) {\n    return Response.redirect(\"https://doc.deno.land/builtin/stable\", 301);\n  }\n\n  if (url.pathname.startsWith(\"/_vsc\")) {\n    return handleVSCRequest(url);\n  }\n\n  const isRegistryRequest =\n    url.pathname.startsWith(\"/std\") || url.pathname.startsWith(\"/x/\");\n\n  if (isRegistryRequest) {\n    if (isHtml) {\n      const ln = extractAltLineNumberReference(url.toString());\n      if (ln) {\n        return Response.redirect(ln.rest + \"#L\" + ln.line, 302);\n      }\n    } else {\n      return handleRegistryRequest(url);\n    }\n  }\n\n  return proxyFile(url, REMOTE_URL, request);\n}\n\nconst ALT_LINENUMBER_MATCHER = /(.*):(\\d+):\\d+$/;\n\nexport function extractAltLineNumberReference(\n  url: string\n): { rest: string; line: number } | null {\n  const matches = ALT_LINENUMBER_MATCHER.exec(url);\n  if (matches === null) return null;\n  return {\n    rest: matches[1],\n    line: parseInt(matches[2]),\n  };\n}\n\nfunction proxyFile(url: URL, remoteUrl: string, request: Request) {\n  const init = {\n    method: request.method,\n    headers: request.headers,\n  };\n  const urlR = remoteUrl + url.pathname;\n  console.log(`Proxy ${url} to ${urlR}`);\n  const modifiedRequest = new Request(urlR, init);\n  console.log(\"modifiedRequest\", modifiedRequest.url);\n  return fetch(modifiedRequest);\n}\n","/* Copyright 2020 the Deno authors. All rights reserved. MIT license. */\n\nconst CDN_ENDPOINT = \"https://cdn.deno.land/\";\nconst API_ENDPOINT = \"https://api.deno.land/\";\n\nexport interface DirEntry {\n  name: string;\n  type: \"file\" | \"dir\" | \"symlink\";\n  size?: number;\n  target?: string;\n}\n\nexport function getSourceURL(\n  module: string,\n  version: string,\n  path: string\n): string {\n  return encodeURI(`${CDN_ENDPOINT}${module}/versions/${version}/raw${path}`);\n}\n\nfunction pathJoin(...parts: string[]) {\n  const replace = new RegExp(\"/{1,}\", \"g\");\n  return parts.join(\"/\").replace(replace, \"/\");\n}\n\nexport function getRepositoryURL(\n  meta: VersionMetaInfo,\n  path: string\n): string | undefined {\n  switch (meta.uploadOptions.type) {\n    case \"github\":\n      return `https://github.com/${pathJoin(\n        meta.uploadOptions.repository,\n        \"tree\",\n        meta.uploadOptions.ref,\n        meta.uploadOptions.subdir ?? \"\",\n        path\n      )}`;\n    default:\n      return undefined;\n  }\n}\n\nexport interface VersionMetaInfo {\n  uploadedAt: Date;\n  directoryListing: DirListing[];\n  uploadOptions: UploadOptions;\n}\n\nexport interface UploadOptions {\n  type: \"github\";\n  repository: string;\n  subdir?: string;\n  ref: string;\n}\n\nexport interface DirListing {\n  path: string;\n  type: \"dir\" | \"file\";\n  size?: number;\n}\n\nexport async function getVersionMeta(\n  module: string,\n  version: string\n): Promise<VersionMetaInfo | null> {\n  const url = `${CDN_ENDPOINT}${module}/versions/${version}/meta/meta.json`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status === 403 || res.status === 404) return null;\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the directory listing:\\n${await res.text()}`\n    );\n  }\n\n  const meta = await res.json();\n  if (!meta) return null;\n\n  return {\n    uploadedAt: new Date(meta.uploaded_at),\n    directoryListing: meta.directory_listing,\n    uploadOptions: meta.upload_options,\n  };\n}\n\nexport interface VersionDeps {\n  graph: DependencyGraph;\n}\n\nexport interface DependencyGraph {\n  nodes: {\n    [url: string]: {\n      deps: string[];\n      size: number;\n    };\n  };\n}\n\nexport async function getVersionDeps(\n  module: string,\n  version: string\n): Promise<VersionDeps | null> {\n  const url = `${CDN_ENDPOINT}${module}/versions/${version}/meta/deps_v2.json`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status === 403 || res.status === 404) return null;\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the dependency information:\\n${await res.text()}`\n    );\n  }\n  const meta = await res.json();\n  if (!meta) return null;\n  return {\n    graph: meta.graph,\n  };\n}\n\nexport interface VersionInfo {\n  latest: string;\n  versions: string[];\n  isLegacy: true;\n}\n\nexport async function getVersionList(\n  module: string\n): Promise<VersionInfo | null> {\n  const url = `${CDN_ENDPOINT}${module}/meta/versions.json`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status === 403 || res.status === 404) return null;\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the version list:\\n${await res.text()}`\n    );\n  }\n  return res.json();\n}\n\nexport interface Module {\n  name: string;\n  description: string;\n  star_count: string;\n}\n\nexport interface SearchResult extends Module {\n  search_score: string;\n}\n\nexport async function listModules(\n  page: number,\n  limit: number,\n  query: string\n): Promise<{ results: SearchResult[]; totalCount: number } | null> {\n  const url = `${API_ENDPOINT}modules?page=${page}&limit=${limit}&query=${encodeURIComponent(\n    query\n  )}`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the module list:\\n${await res.text()}`\n    );\n  }\n  const data = await res.json();\n  if (!data.success) {\n    throw Error(\n      `Got an error (${\n        data.info\n      }) while getting the module list:\\n${await res.text()}`\n    );\n  }\n\n  return { totalCount: data.data.total_count, results: data.data.results };\n}\n\nexport async function getModule(name: string): Promise<Module | null> {\n  const url = `${API_ENDPOINT}modules/${encodeURIComponent(name)}`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status === 404) return null;\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the module ${name}:\\n${await res.text()}`\n    );\n  }\n  const data = await res.json();\n  if (!data.success) {\n    throw Error(\n      `Got an error (${\n        data.info\n      }) while getting the module ${name}:\\n${await res.text()}`\n    );\n  }\n  return data.data;\n}\n\nexport interface Build {\n  id: string;\n  options: {\n    moduleName: string;\n    type: string;\n    repository: string;\n    ref: string;\n    version: string;\n    subdir?: string;\n  };\n  status: string;\n  message?: string;\n}\n\nexport async function getBuild(id: string): Promise<Build> {\n  const url = `${API_ENDPOINT}builds/${id}`;\n  const res = await fetch(url, { headers: { accept: \"application/json\" } });\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the build info:\\n${await res.text()}`\n    );\n  }\n  const data = await res.json();\n  if (!data.success) {\n    throw Error(\n      `Got an error (${\n        data.info\n      }) while getting the build info:\\n${await res.text()}`\n    );\n  }\n  return data.data.build;\n}\n\nexport function parseNameVersion(nameVersion: string): [string, string] {\n  const [name, version] = nameVersion.split(\"@\", 2);\n  return [name, version];\n}\n\nexport function fileTypeFromURL(filename: string): string | undefined {\n  const f = filename.toLowerCase();\n  if (f.endsWith(\".ts\")) {\n    return \"typescript\";\n  } else if (f.endsWith(\".js\")) {\n    return \"javascript\";\n  } else if (f.endsWith(\".tsx\")) {\n    return \"tsx\";\n  } else if (f.endsWith(\".jsx\")) {\n    return \"jsx\";\n  } else if (f.endsWith(\".json\")) {\n    return \"json\";\n  } else if (f.endsWith(\".toml\")) {\n    return \"toml\";\n  } else if (f.endsWith(\".lock\")) {\n    return \"toml\";\n  } else if (f.endsWith(\".rs\")) {\n    return \"rust\";\n  } else if (f.endsWith(\".py\")) {\n    return \"python\";\n  } else if (f.endsWith(\".wasm\")) {\n    return \"wasm\";\n  } else if (f.toLocaleLowerCase().endsWith(\"makefile\")) {\n    return \"makefile\";\n  } else if (f.endsWith(\".dockerfile\") || f.endsWith(\"dockerfile\")) {\n    return \"dockerfile\";\n  } else if (f.endsWith(\".yml\") || f.endsWith(\".yaml\")) {\n    return \"yaml\";\n  } else if (f.endsWith(\".htm\") || f.endsWith(\".html\")) {\n    return \"html\";\n  } else if (\n    f.endsWith(\".md\") ||\n    f.endsWith(\".markdown\") ||\n    f.endsWith(\".mdown\") ||\n    f.endsWith(\".mkdn\") ||\n    f.endsWith(\".mdwn\") ||\n    f.endsWith(\".mkd\")\n  ) {\n    return \"markdown\";\n  } else if (f.endsWith(\".png\") || f.endsWith(\".jpg\") || f.endsWith(\".jpeg\")) {\n    return \"image\";\n  }\n}\n\nexport function fileNameFromURL(url: string): string {\n  const segments = decodeURI(url).split(\"/\");\n  return segments[segments.length - 1];\n}\n\nexport function denoDocAvailableForURL(filename: string): boolean {\n  const filetype = fileTypeFromURL(filename);\n  switch (filetype) {\n    case \"javascript\":\n    case \"typescript\":\n    case \"jsx\":\n    case \"tsx\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function findRootReadme(\n  directoryListing: DirListing[] | undefined\n): DirEntry | undefined {\n  const listing = directoryListing?.find((d) =>\n    /^\\/(docs\\/|\\.github\\/)?readme(\\.markdown|\\.mdown|\\.mkdn|\\.mdwn|\\.mkd|\\.md)?$/i.test(\n      d.path\n    )\n  );\n  return listing\n    ? {\n        name: listing.path.substring(1),\n        type: listing.type,\n        size: listing.size,\n      }\n    : undefined;\n}\n\nexport function isReadme(filename: string): boolean {\n  return /^readme(\\.markdown|\\.mdown|\\.mkdn|\\.mdwn|\\.mkd|\\.md)?$/i.test(\n    filename\n  );\n}\n\nexport type Dep = { name: string; children: Dep[] };\n\nexport function graphToTree(\n  graph: DependencyGraph,\n  name: string,\n  visited: string[] = []\n): Dep | undefined {\n  const dep = graph.nodes[name];\n  if (dep === undefined) return undefined;\n  visited.push(name);\n  return {\n    name,\n    children: dep.deps\n      .filter((n) => !visited.includes(n))\n      .map((n) => graphToTree(graph, n, visited)!),\n  };\n}\n\nexport function flattenGraph(\n  graph: DependencyGraph,\n  name: string,\n  visited: string[] = []\n): string[] | undefined {\n  const dep = graph.nodes[name];\n  if (dep === undefined) return undefined;\n  visited.push(name);\n  dep.deps\n    .filter((n) => !visited.includes(n))\n    .forEach((n) => flattenGraph(graph, n, visited)!);\n  return visited;\n}\n\nfunction matchX(url: string) {\n  const match = url.match(/^https:\\/\\/deno\\.land\\/x\\/([^/]+)(.+)$/);\n  if (!match) return undefined;\n  return {\n    identifier: match[1],\n    path: match[2],\n  };\n}\n\nfunction matchStd(url: string) {\n  const match = url.match(/^https:\\/\\/deno\\.land\\/(x\\/)?std(@([^/]+))?(.+)?$/);\n  if (!match) return undefined;\n  return {\n    version: match[2],\n    submodule: match[4],\n    path: match[5],\n  };\n}\n\nexport function listExternalDependencies(\n  graph: DependencyGraph,\n  name: string\n): string[] | undefined {\n  const visited = flattenGraph(graph, name);\n  const denolandDeps = new Set<string>();\n  const nestlandDeps = new Set<string>();\n  const rawGithubDeps = new Set<string>();\n  const jspmDeps = new Set<string>();\n  const depJsDeps = new Set<string>();\n  const other = new Set<string>();\n  if (visited) {\n    visited.forEach((dep) => {\n      // Count /std only once\n      const std = matchStd(dep);\n      if (std) {\n        denolandDeps.add(`https://deno.land/std${std.version ?? \"\"}`);\n        return;\n      }\n\n      // Count each module on /x only once.\n      const x = matchX(dep);\n      if (x) {\n        denolandDeps.add(`https://deno.land/x/${x.identifier}`);\n        return;\n      }\n\n      // Count each module on nest only once.\n      const nest = dep.match(/^https:\\/\\/x\\.nest\\.land\\/([^/]+)(.+)$/);\n      if (nest) {\n        nestlandDeps.add(`https://nest.land/packages/${nest[1]}`);\n        return;\n      }\n\n      // Count each module on raw.githubusercontent.com only once.\n      const rawGithub = dep.match(\n        /^https:\\/\\/raw\\.githubusercontent\\.com\\/([^/]+)\\/([^/]+)\\/([^/]+)(.+)$/\n      );\n      if (rawGithub) {\n        rawGithubDeps.add(\n          `https://github.com/${rawGithub[1]}/${rawGithub[2]}/tree/${rawGithub[3]}`\n        );\n        return;\n      }\n\n      // Count each module on raw.githubusercontent.com only once.\n      const jspm = dep.match(\n        /^https:\\/\\/dev\\.jspm\\.io\\/(npm:)?(@([^/@]+)\\/([^/@]+)|([^/@]+))@(\\d\\.\\d\\.\\d)(.+)$/\n      );\n      if (jspm) {\n        jspmDeps.add(`https://dev.jspm.io/${jspm[2]}@${jspm[6]}`);\n        return;\n      }\n      if (dep.startsWith(\"https://dev.jspm.io\")) return;\n\n      // Count each module on cdn.depjs.com only once.\n      const depJs = dep.match(/^https:\\/\\/cdn\\.depjs\\.com\\/([^/]+)(.+)$/);\n      if (depJs) {\n        depJsDeps.add(`https://cdn.depjs.com/${depJs[1]}`);\n        return;\n      }\n\n      // Ignore pika internal imports\n      if (dep.startsWith(\"https://cdn.pika.dev/-/\")) return;\n\n      other.add(dep);\n    });\n    const thisStd = matchStd(name);\n    if (thisStd) {\n      denolandDeps.delete(`https://deno.land/std${thisStd.version ?? \"\"}`);\n    }\n    const thisX = matchX(name);\n    if (thisX) {\n      denolandDeps.delete(`https://deno.land/x/${thisX.identifier}`);\n    }\n    return [\n      ...denolandDeps,\n      ...nestlandDeps,\n      ...rawGithubDeps,\n      ...jspmDeps,\n      ...depJsDeps,\n      ...other,\n    ].map((url) =>\n      url.replace(\"https://deno.land/x/std\", \"https://deno.land/std\")\n    );\n  } else return undefined;\n}\n\nexport async function getStats(): Promise<{\n  recently_added_modules: Array<Module & { created_at: string }>;\n  recently_uploaded_versions: Array<{\n    name: string;\n    version: string;\n    created_at: string;\n  }>;\n} | null> {\n  const url = `${API_ENDPOINT}stats`;\n  const res = await fetch(url, {\n    headers: {\n      accept: \"application/json\",\n    },\n  });\n  if (res.status !== 200) {\n    throw Error(\n      `Got an error (${\n        res.status\n      }) while getting the stats:\\n${await res.text()}`\n    );\n  }\n  const data = await res.json();\n  if (!data.success) {\n    throw Error(\n      `Got an error (${\n        data.info\n      }) while getting the stats:\\n${await res.text()}`\n    );\n  }\n\n  return data.data;\n}\n","/* Copyright 2020 the Deno authors. All rights reserved. MIT license. */\n\nimport { match } from \"path-to-regexp\";\nimport { S3_BUCKET } from \"./registry\";\n\nconst VERSIONS = match(\"/_vsc1/modules/:module([a-z0-9_]*)\");\nconst PATHS = match(\"/_vsc1/modules/:module([a-z0-9_]*)/v/:version\");\nconst PATHS_LATEST = match(\"/_vsc1/modules/:module([a-z0-9_]*)/v_latest\");\n\n/**\n * /_vsc1/modules/:module returns a list of all versions for a module\n *\n * /_vsc1/modules/:module/v/:version returns a list of all code files for a version of module\n *\n * /_vsc1/modules/:module/v_latest returns a list of all code files for the latest version of module\n */\nexport async function handleVSCRequest(url: URL): Promise<Response> {\n  const pathname = url.pathname;\n\n  const versions = VERSIONS(pathname);\n  if (versions) {\n    const module = (versions.params as Record<string, string>)[\"module\"];\n    const resp = await fetch(`${S3_BUCKET}${module}/meta/versions.json`);\n    if (resp.status === 403 || resp.status === 404)\n      return new Response(\"module not found\", { status: 404 });\n    if (!resp.ok)\n      return new Response(\"internal server error 1\", { status: 500 });\n    const json = await resp.json();\n    return new Response(JSON.stringify(json.versions), {\n      status: 200,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"cache-control\": \"max-age=86400\",\n      },\n    });\n  }\n\n  const paths = PATHS(pathname);\n  if (paths) {\n    const module = (paths.params as Record<string, string>)[\"module\"];\n    const version = (paths.params as Record<string, string>)[\"version\"];\n    return getPaths(module, version);\n  }\n\n  const pathsLatest = PATHS_LATEST(pathname);\n  if (pathsLatest) {\n    const module = (pathsLatest.params as Record<string, string>)[\"module\"];\n    const resp = await fetch(`${S3_BUCKET}${module}/meta/versions.json`);\n    if (resp.status === 403 || resp.status === 404)\n      return new Response(\"module not found\", { status: 404 });\n    if (!resp.ok)\n      return new Response(\"internal server error 3\", { status: 500 });\n    const json = await resp.json();\n    if (!json.latest) return new Response(\"no latest version\", { status: 404 });\n    return getPaths(module, json.latest);\n  }\n\n  return new Response(\"not found\", { status: 404 });\n}\n\nasync function getPaths(module: string, version: string): Promise<Response> {\n  const resp = await fetch(\n    `${S3_BUCKET}${module}/versions/${version}/meta/meta.json`\n  );\n  if (resp.status === 403 || resp.status === 404)\n    return new Response(\"module or version not found\", { status: 404 });\n  if (!resp.ok) return new Response(\"internal server error 2\", { status: 500 });\n  const json = await resp.json();\n  const list = (json.directory_listing as Array<Record<string, string>>)\n    .filter((f) => f.type === \"file\" && !f.path.includes(\"/_\"))\n    .map((f) => f.path.substring(1))\n    .filter(\n      (f) =>\n        f.endsWith(\".jsx\") ||\n        f.endsWith(\".jsx\") ||\n        f.endsWith(\".ts\") ||\n        f.endsWith(\".tsx\") ||\n        f.endsWith(\".mjs\")\n    );\n  return new Response(JSON.stringify(list), {\n    status: 200,\n    headers: {\n      \"content-type\": \"application/json\",\n      \"cache-control\": \"max-age=86400\",\n    },\n  });\n}\n","/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    // tslint:disable-next-line\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map(token => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x\n  } = options;\n  const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n  const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiter}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n"],"sourceRoot":""}


serve(":8080");
